 ---
title:  "CENTRE ANTOINE LACASSAGNE"
subtitle: "DÉPARTEMENT ÉPIDÉMIOLOGIE, BIOSTATISTIQUES ET DONNÉES DE SANTÉ (DEBDS)"
author: "Responsable: Dr Emmanuel CHAMOREY  \nYann CHATEAU - Data Manager ~ Renaud SCHIAPPA - Data Manager  \nDavid RENER - Data Manager ~ Dr Jocelyn GAL - Biostatisticien  \nBrice THAMPHYA - Bioinformaticien"
date: "Version du: `r format(Sys.time(),'%Y-%m-%d-%Hh%M')`"
abstract: "RAPPORT STATISTIQUE FINAL  \n  \nGDA \n  \nLe biostatisticien et le data manager devront être co-auteur et avoir validé toute publication utilisant les résultats de ce rapport statistique"

output:
  word_document:
      reference_docx: Rapport_analyse_finale_template_markdown.docx
      toc: true
      toc_depth: 4
---
  
```{r setup, include=FALSE}
encoding = "UTF-8"
knitr::opts_chunk$set(
	echo = FALSE,
	warning = FALSE,
	ft.align = "left"
)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
source("C:/Users/Tom/Documents/Cours/Polytech/4A/4A/S1/Analyse_données/PROJET/codageR_TOTAL_R_MARDOWN_EC_BT.R")
source("C:/Users/Tom/Documents/Cours/Polytech/4A/4A/S1/Analyse_données/My_function.R")


#librairies
library(DataCombine)
library(prodlim)
library(binom)
library(gsDesign)
library(cvAUC)
library(caret)
library(vcd)
library(greyzoneSurv)
library(mgcv)
library(randomForest)
library(datasets)
library(keras)
library(mlbench)
library(magrittr)
library(neuralnet)
library(tensorflow)
library(openxlsx)
library(broom)
library(flextable)
#library(idefix)
library(magrittr)
library(dplyr)
library(officer)
library(stringr)
library(forcats)
library(regclass)
library(car)
library(epiDisplay)
library(caTools)
#library(questionr)
```

```{r}
##### paramétrage des sorties tableaux
etude= ""
version= ""
biostat= ""
dm= ""
nom_rapport= "RAPPORT_STATISTIQUE_FINAL6"
auteur_rapport= ""
valide_par= ""

invest= ""
fichier_o= ""
syntaxe=""
donnees= ""
log= "R 3.6.1"
com= "RAS"

col1=c("Étude","Version","Biostatisticien","Data Manager","Nom du Rapport","Auteur du Rapport","Validé par","Investigateur","Fichier original","Syntaxe","Données analysées","Logiciel","Commentaires")
col2=c(etude,version,biostat,dm,nom_rapport,auteur_rapport,valide_par,invest,fichier_o,syntaxe,donnees,log,com)

d1=data.frame(col1,col2)

ft <- flextable(d1)
ft <- align(ft, align = "left")
ft <- bold(ft, j=1, bold = TRUE, part = "body")
ft <- delete_part(ft, part = "header")
ft=fontsize(ft,size = 8, part = "all")
ft <- autofit(ft)
ft=FitFlextableToPage(ft)  ##  à utiliser si le tableau dépasse des marges
#ft
rm(ft)
```

**VALIDATION DU RAPPORT D'ANALYSE FINALE**
  
```{r}
tabvalid<-data.frame(Fonction=c("Biostatisticien","Data manager","Investigateur coordonnateur","Chef de projet","Responsable"),Nom=c("","",""," ","") ,Prenom=c("","",""," ",""),Date="        ",Signature="                    ")

ft <- flextable(tabvalid)
ft<-autofit(ft)
ft <- bold(ft, j=1, bold = TRUE, part = "body")
ft <- bold(ft, bold = TRUE, part = "header")
ft=fontsize(ft,size = 8, part = "all")
ft <- align(ft, align = "left", part = "all" )
ft <- align(ft, j=4, align = "center", part = "body")
ft=height_all(ft, 0.6, part = "body")
ft=border_outer(ft,border = fp_border(color="black"), part = "all")
ft=border_inner_h(ft,border = fp_border(color="black"), part = "all")
ft=border_inner_v(ft,border = fp_border(color="black"), part = "all")
# ft=FitFlextableToPage(ft) ##  à utiliser si le tableau dépasse des marges
#ft
rm(ft)
```

# Import et Pré-traitement avant analyse de la base de données

```{r}
df = readxl::read_xlsx(path = "C:/Users/Tom/Documents/Cours/Polytech/4A/4A/S1/Analyse_données/PROJET/données_sources/BDD.xlsx",
               sheet = 1,
               col_names = TRUE,
               col_types = "text",
               na = c(NA,"NE",""))

# Or ici toutes les colonnes sont de type "text". 
# Toutes les colonnes sont de type "factor". (variables qualitatives)
# Les colonnes 1,6,12,31,44,79 qui sont de type "numeric". ( variables quantitatives)
# Puis les colonnes 4,76,108,120,121,134,161 qui sont de type "character". (commentaires)

############################## ASSOCIATION DU BON TYPE A CHAQUE COLONNE

#on traite cette colonne séparément (on la convertit en factor) car elle contient des modalités avec des lettres "4A" et "4B" ...
df[38]=as.factor(df[[38]])

#ici on convertit les colonnes de type texte en type numeric
col_indx_to_number = c( 1:3 , 5:37, 39:75 , 77:107 , 109:119 , 122:133 , 135:(ncol(df)-1) ) #sauf les colonnes 4,76,108,120,121,134,161 qui doivent rester en type "character"
df[,col_indx_to_number] = lapply( df[,col_indx_to_number] , as.numeric)

#ici on convertit les colonnes en type factor
col_indx_to_factor = c( 2:3 , 5, 7:11, 13:30 , 32:37 , 39:43 , 45:75 , 77:78, 80:107 , 109:119 , 122:133 , 135:(ncol(df)-1) ) #sauf les colonnes 1,6,12,31,44,79 qui sont des nombres
df[,col_indx_to_factor] = lapply( df[,col_indx_to_factor] , as.factor)

############################## SELECTION DES PATIENTS ELIGIBLE

#on ne sélectionne seulement les patients éligibles
df=df[df$ELIGIBILITE==1,]

############################## SUPPRESSION DES COLONNES REDONDANTES

#on enlève une colonne redondante en terme d'apport d'information
df=df[,-7]

df=df[-numcol(c("TI_RADS_4B-5","TI_RADS_<4B","EU_TIRADS","EU_TIRADS_4-5","EU_TIRADS_<4","HYPERECHOGENE"),df)]

############################ RECODAGE DE VARIABLES CATEGORIELLES

df$COLLOIDE[df$COLLOIDE %in% c(0,1)] = 0
df$COLLOIDE[df$COLLOIDE %in% c(2,3)] = 1
df$COLLOIDE=factor(df$COLLOIDE)
names(df)[which(names(df)=="COLLOIDE")]="COLLOIDE_regroup"

df$TI_RADS[df$TI_RADS %in% c(2,3)] = 3
df$TI_RADS=factor(df$TI_RADS)
names(df)[which(names(df)=="TI_RADS")]="TI.RADS.Score"

############################## DERNIER TRAITEMENT POUR "ENJOLIVER" LA BASE

mettre_en_forme <- function(bdd) {
  
  ## MISE EN FORME DE LA VARIABLE DINTERET "CANCER"
  bdd=bdd[-which(names(bdd)=="BENIN")]

  names(bdd)[which(names(bdd)=="MALIN")]="CANCER"
  
  #bdd=bdd[-which(names(bdd)=="SUBJID")]
  
  bdd=bdd[-which(names(bdd)=="ELIGIBILITE")]
  
  # bdd= bdd[ c( which(lapply(bdd, is.factor)==TRUE) , which(lapply(bdd, is.numeric)==TRUE) , which(lapply(bdd, is.character)==TRUE) ) ]
  bdd= bdd[ c( which(lapply(bdd, is.factor)==TRUE) , which(lapply(bdd, is.numeric)==TRUE) ) ]
  
  bdd = bdd %>% relocate(CANCER)
  
  #names(bdd)[names(bdd[,4])]="Age"
  
  names(bdd)[names(bdd)=="ATYPIES_ARCHI_PSEUDO-PAPILLAIRE"]="ATYPIES_ARCHI_PSEUDO_PAPILLAIRE"

  names(bdd)[names(bdd)=="CYTO_SUB-CLASSIF"]="CYTO_SUB_CLASSIF"
  
  names(bdd)[names(bdd)=="cN+"]="cN_plus"
  
  names(bdd)[names(bdd)=="LARGES_LAMBEAUX_ MONOCOUCHES"]="LARGES_LAMBEAUX_MONOCOUCHES"
  
  names(bdd)=str_replace_all(names(bdd),"/","_")
  
  return(bdd) 
}

df=mettre_en_forme(df)

df$Age <- fct_recode(df$Age,
"<55"= "0",
"≥55"="1"
)

df$Consistance <- fct_recode(df$Consistance,
"No"= "0",
"Yes"="1"
)

df$Totally.solid <- fct_recode(df$Totally.solid,
"No"= "0",
"Yes"="1"
)

df$Disurpted.rim.classification <- fct_recode(df$Disurpted.rim.classification,
"No"= "0",
"Yes"="1"
)

df$Hyperthyroidism <- fct_recode(df$Hyperthyroidism,
"No"= "0",
"Yes"="1"
)

df$TI.RADS.Score <- fct_recode(df$TI.RADS.Score,
"2-3"= "3",
"4A"="4A",
"4B"="4B",
)

```

En amont de l'analyse descriptive effectuée ci-dessous, on a opéré une première sélection importante en ne choisissant que les patients qualifiés de "éligibles". 

La proportion de patients non-éligibles représentait 10% de la base données initiale. (1490 dont 153 non-éligibles, 1337 éligibles)

Désormais, la base de données contient 1337 patients. 

Ensuite, parmi ces 1337 patients nous avons remarqué des cas de patients associés à des nodules ni MALIN ni BENIN.

Ces derniers seront considérés comme des cas de nodules "BENIN".

Ces cas "atypiques" représente 5% des patients éligibles (1337 dont 72 "atypique" , 1265 "non-atypique")

On rappelle que notre variable d'intérêt est la variable CANCER. 

Cette variable a été construite telle que elle prend les valeurs :
  "1" si le patient est associé à un nodule "MALIN" , 
  "0" si le patient est associé à un nodule "BENIN".

Pour résumer, nous avons donc ici, une base de données de 1337 patients qui va être le coeur de notre analyse qui contient 143 variables explicatives (majoritairement des variables catégorielles, mais aussi des variables numériques) .

# Analyse descriptive 

```{r}
taille<-dim(df)
taille
```
La dimension de la matrice est de 1337 lignes et 145 colonnes. 

Suppression des patients non éligibles : deja fait dans le prétraitement. 

##Analyse descriptive de la cohorte totale
### Analyse des variables quantitatives

```{r}
###Quantitatives
index=c(140:145)                          #Sélectionne les colonnes d'intérêt à la main
ft=sortiequanti(as.data.frame(df),index)  #Fonction de codage R total, 
#as.data.frame() car problème de format sinon
ft=md_table(ft)                           #Tableau plus joli 
ft                                        #Affichage du tableau 
rm(ft,index)                              #On supprime les valeurs dans index et ft pour les réutiliser après
```

### Analyse des variables qualitatives

```{r}
index=c(1:139) 
ft=sortiequali(as.data.frame(df),index)
ft =md_table(ft)
ft 
rm(ft,index)
```


```{r,include=FALSE}
#est ce utile => NON  
# strata("ATCD_FAM_CT")
# strata("ATCD_IRRAD")
# strata("HASHIMOTO")
# strata("Hyperthyroidism")
# strata("ATS")
# strata("BASEDOW")
# strata("OBESITE")
# strata("TAILLE_>4CM")
# strata("REGULARITE")
# strata("SIGNES_INVASION")
# strata("DOULEUR")
```

## Création de sous groupes en fonction du centre 

```{r,echo=T}
#utiliser filtre ou group_by du module dyplr
valid<-rbind(df[(df$CENTRE==4),],df[(df$CENTRE==5),]) #Toulouse
Nice<-rbind(df[(df$CENTRE==1),],df[(df$CENTRE==2),],df[(df$CENTRE==3),],df[(df$CENTRE==6),])#Nice
appren_int<-sample(nrow(Nice),nrow(Nice)*0.7)
appren<-Nice[appren_int,]
valid_2<-Nice[-appren_int,]
dim(appren)
dim(valid_2)
dim(Nice)

# rm(valid_2)
# Ech= sample.split(Nice$anycolumn,SplitRatio=0.7)
# appren=subset(Nice,Ech==TRUE)
# valid_2=subset(Nice,Ech==FALSE)
# dim(Nice)
# dim(valid_2)
# dim(appren)


#Q annexe => Créer autre bdd où on part du principe qu'il n'y a pas de centre que cohorte de validation ou d'apprentissage 
```

##Analyse descriptive de la cohorte d'apprentissage
### Analyse descriptive des variables quantitatives pour la cohorte d'apprentissage
```{r,include=F}
index=c(140:145)
ft=sortiequanti(as.data.frame(appren),index)
ft=md_table(ft)
ft 
rm(ft,index)
```


### Analyse descriptive des variables qualitatives pour la cohorte d'apprentissage
```{r,include=F}
index=c(1:139) 
ft=sortiequali(as.data.frame(appren),index)
ft =md_table(ft)
ft 
rm(ft,index)
```

##Analyse descriptive de la cohorte de validation
### Analyse descriptive des variables quantitatives pour la cohorte de validation(Toulouse) 
```{r,include=F}
index=c(140:145)
#md_table(sortiequanti(as.data.frame(valid),index))
ft=sortiequanti(as.data.frame(valid),index)
ft=md_table(ft)
ft
rm(ft,index)
```

### Analyse descriptive des variables qualitatives pour la cohorte de validation(Toulouse)
```{r,include=F}
index=c(1:139) 
ft=sortiequali(as.data.frame(valid),index)
ft =md_table(ft)
ft 
rm(ft,index)
```

### Analyse descriptive des variables quantitatives pour la cohorte de validation(30% de Nice)
```{r,include=F}
index=c(140:145)
#md_table(sortiequanti(as.data.frame(valid),index))
ft=sortiequanti(as.data.frame(valid_2),index)
ft=md_table(ft)
ft
rm(ft,index)
```

### Analyse descriptive des variables qualitatives pour la cohorte de validation(30% de Nice)
```{r,include=F}
index=c(1:139) 
ft=sortiequali(as.data.frame(valid_2),index)
ft =md_table(ft)
ft 
rm(ft,index)
```

# Analyse uni-variée

```{r}
dim(appren)
appren<-drop_level_0_and_unassociate(appren,1)
dim(appren)
```


```{r}
# for(i in c(1:ncol(appren))){appren[,i]<-droplevels(appren[,i])}
# dim(appren)
```

```{r}
#ADENOME=107
n<-ncol(appren)

suppr<-function(database){
  index<-c()
  for (i in c(3:ncol(database))){
    if (any(colSums(table(database[[i]],database$CANCER))==0)){
      ##On teste si au moins une des modalité/level n'a pas été observé avec la variable explicative
      index<-c(index,i)
      #appren[[i]]<-NULL
      #n-1
      next
    }
  }
  for (i in c(index)){
    database[[i]]<-NULL
    index-1
    next}
}
rm(index)

# i<-3
# n<-ncol(appren)
# while(i!=n){ ##On teste l'égalite entre deux itérateur => éviter pb quand on supprime ligne "du out of range"
#   ##On teste si au moins une des modalité/level n'a pas été observé avec la variable explicative
#   if (any(colSums(table(appren[[i]],appren$CANCER))==0)){
#       appren[[i]]<-NULL
#       n-1
#       next
#   }
#   i+1
#   print(n)
#   print(i)
#   next
# }
# dim(appren)

# nm<-colnames(data_base[i])
# data_base$nm<-factor( data_base$nm )
# data_base[,i]<-as.factor(as.character(data_base[,i]))
# data_base$colnames(data_base[,i]) <- factor( data_base$colnames(data_base[i]) )
# data_base$names(data_base[,i])<-droplevels( data_base$names(data_base[,i]) )
# print(levels(data_base$colnames(i)))
# Si oui, on supprime ces modalitées
# test1[,i]<-as.factor(as.character(test1[,i]))

```

```{r}
i<-3
n<-ncol(appren)
while(i!=n){ ##On teste l'égalite entre deux itérateur => éviter pb quand on supprime ligne "du out of range"
  ##On teste si au moins une des modalité/level n'a pas été observé avec la variable explicative
  if (any(colSums(table(appren[[i]],appren$CANCER))==0)){
    appren[[i]]<-NULL
    n<-n-1
    next}
  i<-i+1
  next
}
dim(appren)
```



```{r}
# index<-c()
# for (i in c(3:117)){
#   if (any(colSums(table(appren[[i]],appren$CANCER))==0)){
#     ##On teste si au moins une des modalité/level n'a pas été observé avec la variable explicative
#     #index<-c(index,i)
#     appren[[i]]<-NULL
#     #n-1
#     next
#   }
# }
```


```{r}
#Si une des modalité est égale à 0 on la supprime
# drop_modal_0 <- function(data_base){
#   for (i in c(1:ncol(data_base))){
#     if (any(table(data_base[i])==0)){    ##On teste si au moins une des modalité/level est égale                                                                                             à 0
      # nm<-colnames(data_base[i])
      # data_base$nm<-factor( data_base$nm )
      #data_base[,i]<-as.factor(as.character(data_base[,i]))
      #data_base$colnames(data_base[,i]) <- factor( data_base$colnames(data_base[i]) )
      #data_base$names(data_base[,i])<-droplevels( data_base$names(data_base[,i]) )
      #print(levels(data_base$colnames(i)))
      # Si oui, on supprime ces modalitées
      #test1[,i]<-as.factor(as.character(test1[,i]))
#     }
#   return(data_base)
#   }
# }
```

```{r}
#Cellularité = col67 
# appren<-drop_modal_0(appren)
# table(appren$CELLULARITE)
#appren$colnames(appren[,67])
#table(factor(appren$CELLULARITE))
```

```{r}
# for(i in c(1:139)){appren[,i]<-droplevels(appren[,i])}
# table(appren$CELLULARITE)
```



```{r}
tt=tableStack(vars=3:ncol(appren),
              by=CANCER,
              dataFrame=as.data.frame(appren),
              na.col=T)
bold_lines=which(tt[,1] %in% colnames(appren))#Met les noms en gras
colnames(tt)[1:3]=c("CANCER","Benin","Malin") #on attribue les noms des colones
md_table(tt,bold.names=bold_lines)
#taille==dim(test1)

```

```{r}
# col_significatives<- function(DataBase,
#                               nom_Tableau_Table_Stack,
#                               indice_significativité=0.05,## Valeur par défaut 
#                               indice=FALSE)
#   {
#   nonvide=nom_Tableau_Table_Stack$`P value`[which((nom_Tableau_Table_Stack$`P value`=="")==FALSE)]
#   ##On recherche les lignes non vide du table stack pour la colonne 'P Value' 
#   nonvide = replace(nonvide,
#                     which(nonvide=="< 0.001"),
#                     0) 
#   #remplacer les valeurs < 0.001(caractère) par 0 (int)
#   
#   indices<-which(nonvide<=indice_significativité) ##Récup des indices des colonnes significatives 
#   if (indice==TRUE){
#     return (indices)}
#   # récup des indices des lignes avec pvalue <= indice de significativité 
#   col_sign<-colnames(DataBase[indices+1]) ###Question : ca serais pas tt plutot que DB
#   # on récup les noms des colonnes des indices sélectionner.
#   if(indice==FALSE){
#     return (col_sign)}#Si on cherche les noms alors on renvoie les noms des colonnes significatives
# }
```


```{r}
rm(signif)
source("C:/Users/Tom/Documents/Cours/Polytech/4A/4A/S1/Analyse_données/My_function.R")

signif=col_significatives(appren,tt,indice=FALSE,nb_début_vars_TableStack = 3)
signif

#rm(tt)
```
Supprimer les valeurs ayant plus de 50 % de vide début desceiptive pour multivariée 

[,indice]=> on sélectionne la ligne
[indice,]=> on sélectionne la colonne 


```{r}
# drop_nb_na_sup_50_pourcent<-function(DataBase){
#   i<-1  #Enlever la variable explicative et la variable de découpage de la bdd 
#   n<-ncol(DataBase)
#   while(i!=n){ ##On teste l'égalite entre deux itérateur => éviter pb quand on supprime ligne "du out of range"
#     if ((sum(is.na(DataBase[i]))/nrow(DataBase))>=0.5){
#       colonne_supr<-c(colonne_supr,names(DataBase[i])) 
#       #ajout dans une "liste" le nom de la variable supprimé
#       DataBase[[i]]<-NULL #suppression de la colonne liée à la variable expl
#       n<-n-1  #Diminuer de 1 si on supprime une colonne 
#       next}
#     i<-i+1
#     next}
#   a<-c("Data"=DataBase,"Noms"=colonne_supr)
#   return(a)
# }
```


```{r}
index_ou_names_nb_na_sup_50_pourcent<-function(DataBase,index=FALSE){
  colonne_supr<-c()
  for(i in c(1:ncol(DataBase))){
    if ((sum(is.na(DataBase[i]))/nrow(DataBase))>=0.5){
      colonne_supr<-c(colonne_supr,i)
      #ajout dans une "liste" le nom de la variable supprimé
      next}
  }
  if(index==TRUE){return(colonne_supr)}
  else{return(colnames(DataBase[colonne_supr]))}
}

drop_nb_na_sup_50_pourcent<-function(DataBase,names){
  for (i in names){DataBase$i<-NULL}
  return (DataBase)
}
```

```{r}
index_ou_names_nb_na_sup_50_pourcent(appren,index=TRUE)
colonne<-index_ou_names_nb_na_sup_50_pourcent(appren,index=FALSE)
colonne 
appren_nett<-drop_nb_na_sup_50_pourcent(appren,colonne)
dim(appren_nett)
dim(appren)
```


```{r}
dim(appren)
appren_nettoyé<-drop_nb_na_sup_50_pourcent(appren)
dim(appren_nettoyé)
```


```{r,eval=F}
#rmarkdown::render(input= "GDA_ANALYSE_FINALE.Rmd",
     #output_file = paste0("RAPPORT_STAT_GDA",format(Sys.time(),'%Y-%m-%d-%Hh%M'),".docx"),
     #output_dir ="/Users/jgal/Google Drive/GDA/")
```     